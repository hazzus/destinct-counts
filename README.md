# Тестовое задание для стажировки в команду баз данных ВК
## Задание 1:
Необходимо написать код, который эффективным образом найдёт количество общих элементов в двух массивах int-ов. 
Можно считать, что элементы внутри каждого массива не повторяются. Уделите внимание случаю, когда один список 
намного меньше другого по размеру. Кроме того, необходимо написать код, который тестирует правильность алгоритма. 

Что будет оцениваться: 
1. Правильность работы алгоритма. 
2. Скорость работы. Важна не только асимптотика, но и скрытая в ней константа. 
3. Полнота тестов. Неправильно написанный алгоритм не должен проходить ваш тест. 
4. Читаемость кода. 

В нескольких предложениях опишите используемый алгоритм, какие есть альтернативы и почему ваш алгоритм лучше. 

### Описание алгоритма
Возьмем меньший из двух массивов, отсортируем его( `O(nlogn)` ). Проходясь по второму массиву будем искать текущий элемент
бинарным  поиском в первом ( `O(mlogn)` ). Если совпадение, то увеличиваем счетчик. Общая ассимптотика `O((n + m)logn)`. 

### Альтернативы
1. **Использовать set вместо бинарного поиска**. В этом случае время работы такое же, но тратится время на аллокацию ресурсов + используется дополнительная память.
2. **Использовать hashset**. В среднем это будет даже быстрее, ведь добавление и поиск в нем - амортизированная константа
( Общая была бы `O(n + m)` ) Однако опять требуется дополнительная память + на плохих входных данных время может ухудшаться до
`O((n + m)n)`
3. **Простейший перебор**. Так я выполняю проверку рандомизированных тестов. Время работы в таком случае очень большое: `O(nm)`


## Задание 2:
Необходимо написать алгоритм, который приблизительно подсчитывает количество различных чисел в массиве, используя константный объём памяти. 

Более формально, надо реализовать класс с двумя функциями:

- `void add(int x);` — добавить число x к набору;
- `int get_uniq_num();` — возвращает приблизительное количество различных чисел, которые были переданы в функцию add.

Ваш класс должен использовать не более 32 Кб памяти. 

### Описание алгоритма
Используется HyperLogLog Algorithm. Описан в этой статье: http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf

Так же описан Linear Probability Counter. Описан в этой статье: http://algo.inria.fr/flajolet/Publications/src/FlMa85.pdf


### Альтернативы:
MinCount, LogLog, но у них хоть и меньше расход памяти, но они менее прогрессивны и больше ошибаются.
